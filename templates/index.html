<!doctype html>
<meta charset="utf-8">
<title>Video + YOLO Boxes Viewer</title>
<style>
  body { font-family: sans-serif; margin: 0; }
  .wrap { display: grid; grid-template-columns: 2fr 1fr; gap: 12px; padding: 12px; }
  .player { position: relative; width: 100%; }
  video { max-height: 78vh; background: #00000000; object-fit: contain; }
  canvas { position: absolute; left: 0; top: 0; pointer-events: none; }
  .panel { border: 1px solid #ddd; padding: 12px; }
  .row { display: flex; gap: 8px; flex-wrap: wrap; align-items: center; margin: 8px 0; }
  button { padding: 8px 12px; cursor: pointer; }
  select { padding: 6px 10px; }
  #timeline { width: 100%; height: 60px; border: 1px solid #ddd; }
  pre { white-space: pre-wrap; font-size: 12px; }
  #seek { height: 18px; }
  #time { font-variant-numeric: tabular-nums; font-size: 12px; min-width: 120px; text-align: right; }
  
  /* 카운터 스타일 */
  .counter-box { margin-bottom: 20px; padding-bottom: 20px; border-bottom: 1px solid #eee; }
  .counter-row { display: flex; align-items: center; justify-content: space-between; margin-bottom: 8px; font-size: 16px; font-weight: bold; }
  .counter-controls button { padding: 4px 8px; font-size: 12px; }
  .log-preview { max-height: 200px; overflow-y: auto; background: #f9f9f9; border: 1px solid #eee; padding: 4px; font-size: 11px; margin-top: 8px; }
  
  .btn-group { display: flex; gap: 5px; margin-top: 8px; }
  .download-btn { flex: 1; background-color: #4CAF50; color: white; border: none; }
  .download-btn:hover { background-color: #45a049; }
  .clear-btn { flex: 1; background-color: #f44336; color: white; border: none; }
  .clear-btn:hover { background-color: #d32f2f; }

  /* [추가됨] 완료 상태 버튼 스타일 */
  #toggleCompleteBtn {
    font-weight: bold;
    border: 1px solid #ccc;
    border-radius: 4px;
    transition: all 0.2s;
  }
  /* 미완료 상태 (기본) */
  #toggleCompleteBtn.incomplete {
    background-color: #f0f0f0;
    color: #555;
  }
  #toggleCompleteBtn.incomplete:hover {
    background-color: #e0e0e0;
  }
  /* 완료 상태 */
  #toggleCompleteBtn.completed {
    background-color: #4CAF50; /* Green */
    color: white;
    border-color: #45a049;
  }
  #toggleCompleteBtn.completed:hover {
    background-color: #45a049;
  }
</style>

<div class="wrap">
  <div>
    <div class="row">
      <label>Video:</label>
      <select id="sel"></select>
      <button id="reload">Reload list</button>
      
      <button id="toggleCompleteBtn" class="incomplete" onclick="toggleCompletion()">Mark as Completed</button>
      
      <label style="margin-left:12px;"><input type="checkbox" id="overlay" checked> Overlay</label>
    </div>

    <div class="player" id="player">
      <video id="v" preload="metadata" playsinline></video>
      <canvas id="c"></canvas>
    </div>

    <div class="row">
      <button id="prevHit">Prev hit</button>
      <button id="nextHit">Next hit</button>
      
      <button id="prevF" style="margin-left:auto;">-1 frame</button>
      <button id="nextF">+1 frame</button>

      <button id="playPause">Play</button>
      <label style="display:flex; align-items:center; gap:4px;">
        Speed
        <select id="speed">
          <option value="0.25">0.25x</option>
          <option value="0.5">0.5x</option>
          <option value="1" selected>1x</option>
          <option value="1.5">1.5x</option>
          <option value="2">2x</option>
          <option value="4">4x</option>
        </select>
      </label>
      <input id="seek" type="range" min="0" max="0" step="0.001" value="0" style="flex:1; min-width:220px;">
      <span id="time">00:00:00 / 00:00:00</span>
      <span id="info"></span>
    </div>

    <div class="row">
      <div style="flex:1;">
        <div style="font-size:12px; margin-bottom:4px;">Timeline (click to seek)</div>
        <canvas style="position: relative;" id="timeline"></canvas>
      </div>
    </div>
  </div>

  <div class="panel">
    <div class="counter-box">
      <h3 style="margin-top:0;">Video Log</h3>
      <div style="font-size:11px; color:#666; margin-bottom:10px;">
        * Logs & Completion status are saved automatically.
      </div>

      <div class="counter-row">
        <span style="color: blue;">IN (Key: I)</span>
        <span id="displayIn">0</span>
        <div class="counter-controls">
          <button onclick="manualAdjust('in', 1)">+</button>
          <button onclick="manualAdjust('in', -1)">-</button>
        </div>
      </div>
      <div class="counter-row">
        <span style="color: red;">OUT (Key: O)</span>
        <span id="displayOut">0</span>
        <div class="counter-controls">
          <button onclick="manualAdjust('out', 1)">+</button>
          <button onclick="manualAdjust('out', -1)">-</button>
        </div>
      </div>
      
      <div class="btn-group">
        <button class="download-btn" onclick="downloadCSV()">Download This Log</button>
        <button class="clear-btn" onclick="clearCurrentVideoLog()">Clear This Video</button>
      </div>
      
      <div style="font-size: 12px; margin-top: 8px; font-weight: bold;">Current Video Logs:</div>
      <div id="logPreview" class="log-preview"></div>
    </div>

    <h3 style="margin-top:10px;">Current boxes</h3>
    <div style="font-size:11px; color:#666; margin-bottom:4px;">
      * Viewing pre-cleaned data
    </div>
    <pre id="boxes">-</pre>
  </div>
</div>

<script>
  const FPS = Number('{{ FPS }}');

  // --- HTML Elements ---
  const sel = document.getElementById('sel');
  const v = document.getElementById('v');
  const c = document.getElementById('c');
  const ctx = c.getContext('2d');
  const overlayToggle = document.getElementById('overlay');
  const boxesPre = document.getElementById('boxes');
  const info = document.getElementById('info');
  const playPauseBtn = document.getElementById('playPause');
  const seek = document.getElementById('seek');
  const timeLbl = document.getElementById('time');
  const speedSelect = document.getElementById('speed');
  const tl = document.getElementById('timeline');
  const tlx = tl.getContext('2d');
  const toggleCompleteBtn = document.getElementById('toggleCompleteBtn'); // [추가]

  // --- Global State ---
  let isSeeking = false;
  let currentVideo = null;
  let videoList = []; // [추가] 비디오 목록 저장용
  let lastFrame = -1;
  let timeline = null; 
  let binSec = 1;
  const BOX_CHUNK_FRAMES = Math.max(30, Math.round(FPS * 2)); 
  let boxesCache = new Map();
  let inflightBoxes = null;
  let currentSpeed = parseFloat(speedSelect.value) || 1;

  // --- Counter & Session State ---
  let sessionData = {}; 
  let completedStates = {}; // [추가] 완료 상태 저장용 { "video_id": true/false }

  let countIn = 0;
  let countOut = 0;
  let eventLogs = []; 

  const displayIn = document.getElementById('displayIn');
  const displayOut = document.getElementById('displayOut');
  const logPreview = document.getElementById('logPreview');

  // --- Utility Functions ---
  function clamp(x, a, b) { return Math.max(a, Math.min(b, x)); }
  function formatTime(seconds) {
    if (!Number.isFinite(seconds)) return "00:00:00";
    const h = Math.floor(seconds / 3600).toString().padStart(2, '0');
    const m = Math.floor((seconds % 3600) / 60).toString().padStart(2, '0');
    const s = Math.floor(seconds % 60).toString().padStart(2, '0');
    return `${h}:${m}:${s}`;
  }

  // --- LocalStorage Management ---
  function loadSessionFromStorage() {
    // 1. 로그 데이터 로드
    const savedSession = localStorage.getItem('BEE_COUNTER_SESSION_V2');
    if (savedSession) {
      try { sessionData = JSON.parse(savedSession); } catch (e) { sessionData = {}; }
    }
    // 2. 완료 상태 데이터 로드
    const savedStates = localStorage.getItem('BEE_COMPLETED_STATES');
    if (savedStates) {
      try { completedStates = JSON.parse(savedStates); } catch (e) { completedStates = {}; }
    }
  }

  function saveSessionToStorage() {
    if (currentVideo) {
      sessionData[currentVideo] = { in: countIn, out: countOut, logs: eventLogs };
    }
    localStorage.setItem('BEE_COUNTER_SESSION_V2', JSON.stringify(sessionData));
  }
  
  function saveCompletionState() {
    localStorage.setItem('BEE_COMPLETED_STATES', JSON.stringify(completedStates));
  }

  // --- [추가] Completion Toggle Logic ---
  window.toggleCompletion = function() {
    if (!currentVideo) return;
    
    // 상태 반전
    const isComplete = !completedStates[currentVideo];
    completedStates[currentVideo] = isComplete;
    saveCompletionState();
    
    // UI 업데이트 (버튼 및 드롭다운)
    updateCompletionUI();
    renderVideoDropdown(); // 드롭다운의 체크표시 갱신
  };
  
  function updateCompletionUI() {
    if (!currentVideo) return;
    
    const isComplete = completedStates[currentVideo];
    if (isComplete) {
      toggleCompleteBtn.textContent = "Completed ✅";
      toggleCompleteBtn.className = "completed";
    } else {
      toggleCompleteBtn.textContent = "Mark as Completed";
      toggleCompleteBtn.className = "incomplete";
    }
  }

  // --- Data Loading ---
  async function loadVideos() {
    loadSessionFromStorage(); 

    const r = await fetch('/api/videos');
    videoList = await r.json(); // 전역 변수에 저장
    
    renderVideoDropdown(); // 드롭다운 그리기 분리

    if (videoList.length) {
      // 이전에 선택했던 비디오가 있으면 유지, 없으면 첫 번째
      if (!currentVideo) currentVideo = videoList[0].video_id;
      // 셀렉트 박스 값 동기화
      sel.value = currentVideo;
      await selectVideo(sel.value);
    }
  }
  
  // [수정] 드롭다운 렌더링 함수 (완료 표시 포함)
  function renderVideoDropdown() {
    // 현재 선택된 값 기억
    const currentSelection = sel.value;
    
    sel.innerHTML = '';
    for (const it of videoList) {
      const opt = document.createElement('option');
      opt.value = it.video_id;
      
      // 완료된 영상이면 앞에 체크표시 추가
      const isDone = completedStates[it.video_id] ? "✅ " : "";
      opt.textContent = `${isDone}${it.video_id}`;
      
      opt.dataset.url = it.url;
      sel.appendChild(opt);
    }
    
    // 값 복구
    if (currentSelection) {
      sel.value = currentSelection;
    }
  }

  async function selectVideo(video_id) {
    if (currentVideo) {
      sessionData[currentVideo] = { in: countIn, out: countOut, logs: eventLogs };
      saveSessionToStorage();
    }

    currentVideo = video_id;
    lastFrame = -1;
    boxesPre.textContent = '-';
    info.textContent = '';
    clearBoxesCache();
    
    // 세션 로드
    if (sessionData[video_id]) {
      const data = sessionData[video_id];
      countIn = data.in || 0;
      countOut = data.out || 0;
      eventLogs = data.logs || [];
    } else {
      countIn = 0; countOut = 0; eventLogs = [];
    }
    
    updateCounterUI();
    renderLogs();
    
    // [추가] 완료 상태 버튼 업데이트
    updateCompletionUI();

    // 선택된 옵션의 URL 찾기
    const selectedOption = Array.from(sel.options).find(opt => opt.value === video_id);
    if (!selectedOption) return; // 방어 코드

    const url = selectedOption.dataset.url;
    v.src = url;
    v.load();
    setPlaybackRate(currentSpeed);

    playPauseBtn.textContent = 'Play';
    seek.value = '0';
    seek.max = '0';
    timeLbl.textContent = '00:00:00 / 00:00:00';

    const tr = await fetch(`/api/videos/${video_id}/timeline?bin_sec=${binSec}`);
    const tj = await tr.json();
    timeline = tj.counts;
    drawTimeline();

    v.onloadedmetadata = () => {
      resizeCanvasToVideo();
      resizeTimeline();
      drawTimeline();
      schedulePrefetch(0);
      if (Number.isFinite(v.duration)) {
        seek.max = String(Math.max(0, v.duration));
        timeLbl.textContent = `${formatTime(v.currentTime)} / ${formatTime(v.duration)}`;
      }
    };
  }

  // --- Counter & Log Functions ---
  function updateCounterUI() {
    if (displayIn) displayIn.textContent = countIn;
    if (displayOut) displayOut.textContent = countOut;
  }
  function renderLogs() {
    logPreview.innerHTML = '';
    for (let i = eventLogs.length - 1; i >= 0; i--) {
      const log = eventLogs[i];
      const timeStr = formatTime(log.rawTime);
      const div = document.createElement('div');
      div.innerHTML = `<span style="color:#666">[${timeStr}]</span> ${log.type}`;
      logPreview.appendChild(div);
    }
  }
  function addLog(type) {
    eventLogs.push({ rawTime: v.currentTime, type: type });
    renderLogs();
    saveSessionToStorage(); 
  }
  function removeLastLog(type) {
    for (let i = eventLogs.length - 1; i >= 0; i--) {
      if (eventLogs[i].type === type) {
        eventLogs.splice(i, 1); renderLogs(); saveSessionToStorage(); return;
      }
    }
  }
  window.manualAdjust = function(type, delta) {
    if (type === 'in') {
      if (delta > 0) { countIn++; addLog('IN'); } 
      else if (countIn > 0) { countIn--; removeLastLog('IN'); }
    } else {
      if (delta > 0) { countOut++; addLog('OUT'); } 
      else if (countOut > 0) { countOut--; removeLastLog('OUT'); }
    }
    updateCounterUI();
  };
  window.clearCurrentVideoLog = function() {
    if (confirm(`'${currentVideo}'의 로그를 초기화하시겠습니까?`)) {
      countIn = 0; countOut = 0; eventLogs = [];
      updateCounterUI(); renderLogs(); saveSessionToStorage();
    }
  };
  window.downloadCSV = function() {
    if (eventLogs.length === 0) { alert("No logs for this video."); return; }
    let csv = "data:text/csv;charset=utf-8,Video ID,Video Time,Real Time,Type\n"; 
    eventLogs.forEach(row => {
      csv += `${currentVideo},${formatTime(row.rawTime)},${formatTime(row.rawTime + 28800)},${row.type}\n`;
    });
    csv += `\nSummary,,\nTotal IN,${countIn},\nTotal OUT,${countOut},\n`;
    const encodedUri = encodeURI(csv);
    const link = document.createElement("a");
    link.setAttribute("href", encodedUri);
    link.setAttribute("download", `log_${currentVideo}.csv`);
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
  };

  // --- Standard Player Logic ---
  function resizeCanvasToVideo() {
    const rect = v.getBoundingClientRect();
    c.width = Math.floor(rect.width);
    c.height = Math.floor(rect.height);
    c.style.width = rect.width + 'px';
    c.style.height = rect.height + 'px';
  }
  function resizeTimeline() {
    const rect = tl.getBoundingClientRect();
    tl.width = Math.floor(v.getBoundingClientRect().width);
    tl.style.width = tl.width + 'px';
    tl.height = Math.floor(rect.height);
  }
  function setPlaybackRate(rate) {
    const r = Number.isFinite(rate) ? rate : 1;
    currentSpeed = r;
    v.playbackRate = r;
    speedSelect.value = String(r);
  }
  function clearBoxesCache() {
    boxesCache = new Map();
    inflightBoxes = null;
  }
  async function fetchBoxesRange(start, end) {
    if (!currentVideo) return {};
    const r = await fetch(`/api/videos/${currentVideo}/boxes_range?start_frame=${start}&end_frame=${end}`);
    if (!r.ok) return {};
    const j = await r.json();
    for (const [k, v] of Object.entries(j.boxes || {})) {
      boxesCache.set(Number(k), v);
    }
    return j.boxes || {};
  }
  function schedulePrefetch(frame) {
    const start = Math.max(0, frame - Math.floor(BOX_CHUNK_FRAMES / 3));
    const end = start + BOX_CHUNK_FRAMES - 1;
    if (inflightBoxes && frame >= inflightBoxes.start && frame <= inflightBoxes.end) {
      return inflightBoxes.promise;
    }
    const promise = fetchBoxesRange(start, end).finally(() => {
      if (inflightBoxes && inflightBoxes.promise === promise) inflightBoxes = null;
    });
    inflightBoxes = { start, end, promise };
    return promise;
  }
  async function getBoxesForFrame(frame) {
    const cached = boxesCache.get(frame);
    if (cached) return cached;
    await schedulePrefetch(frame);
    return boxesCache.get(frame) || [];
  }
  function currentFrame() {
    return Math.max(0, Math.round(v.currentTime * FPS));
  }
  function drawBoxes(boxes) {
    ctx.clearRect(0, 0, c.width, c.height);
    if (!overlayToggle.checked) return;
    if (!boxes || boxes.length === 0) return;
    const vw = v.videoWidth;
    const vh = v.videoHeight;
    if (!vw || !vh) return;
    const sx = c.width / vw;
    const sy = c.height / vh;
    ctx.lineWidth = 2;
    ctx.strokeStyle = 'red';
    for (const b of boxes) {
      const w = b.width * sx;
      const h = b.height * sy;
      const x = b.x * sx - w / 2;
      const y = b.y * sy - h / 2;
      ctx.strokeRect(x, y, w, h);
    }
    boxesPre.textContent = `Count: ${boxes.length}\n` + JSON.stringify(boxes, null, 2);
  }
  async function tick() {
    if (v.readyState >= 2 && currentVideo) {
      const f = currentFrame();
      if (f !== lastFrame) {
        lastFrame = f;
        const cached = boxesCache.get(f);
        const boxes = cached || [];
        if (!cached) schedulePrefetch(f);
        drawBoxes(boxes);
        info.textContent = `t=${formatTime(v.currentTime)}, frame=${f}`;
      }
    }
    requestAnimationFrame(tick);
  }
  function drawTimeline() {
    if (!timeline) return;
    if (!tl.width) resizeTimeline();
    const W = tl.width, H = tl.height;
    tlx.clearRect(0, 0, W, H);
    const n = timeline.length;
    if (n === 0) return;
    let maxv = 1;
    for (let i = 0; i < n; i++) maxv = Math.max(maxv, timeline[i]);
    for (let i = 0; i < n; i++) {
      const x0 = Math.floor(i * W / n);
      const x1 = Math.floor((i + 1) * W / n);
      const v = timeline[i];
      if (v <= 0) continue;
      const h = Math.floor((v / maxv) * (H - 2));
      tlx.fillRect(x0, H - h, Math.max(1, x1 - x0), h);
    }
  }
  function updatePlayPauseLabel() {
    playPauseBtn.textContent = v.paused ? 'Play' : 'Pause';
  }
  function updateTimeUI() {
    if (!isSeeking && Number.isFinite(v.currentTime)) {
      seek.value = String(v.currentTime);
    }
    const dur = Number.isFinite(v.duration) ? v.duration : 0;
    timeLbl.textContent = `${formatTime(v.currentTime)} / ${formatTime(dur)}`;
  }
  playPauseBtn.addEventListener('click', async () => {
    v.paused ? v.play().catch(()=>{}) : v.pause();
    updatePlayPauseLabel();
  });
  v.addEventListener('click', async () => {
    v.paused ? v.play().catch(()=>{}) : v.pause();
    updatePlayPauseLabel();
  });
  v.addEventListener('play', updatePlayPauseLabel);
  v.addEventListener('pause', updatePlayPauseLabel);
  v.addEventListener('timeupdate', updateTimeUI);
  v.addEventListener('durationchange', () => {
    if (Number.isFinite(v.duration)) seek.max = String(Math.max(0, v.duration));
    updateTimeUI();
  });
  speedSelect.addEventListener('change', () => setPlaybackRate(parseFloat(speedSelect.value)));
  seek.addEventListener('input', () => {
    isSeeking = true;
    const dur = Number.isFinite(v.duration) ? v.duration : 0;
    timeLbl.textContent = `${formatTime(Number(seek.value))} / ${formatTime(dur)}`;
  });
  seek.addEventListener('change', () => {
    v.currentTime = clamp(Number(seek.value), 0, v.duration - 0.001);
    isSeeking = false; lastFrame = -1;
  });
  window.addEventListener('keydown', (e) => {
    const tag = (e.target && e.target.tagName) ? e.target.tagName.toLowerCase() : '';
    if (['input','select','textarea'].includes(tag)) return;
    if (e.code === 'Space') { e.preventDefault(); v.paused ? v.play().catch(()=>{}) : v.pause(); }
    else if (e.code === 'ArrowLeft') { e.preventDefault(); moveFrame(-1); lastFrame = -1; }
    else if (e.code === 'ArrowRight') { e.preventDefault(); moveFrame(1); lastFrame = -1; }
    else if (e.key.toLowerCase() === 'n') { e.preventDefault(); jumpHit('next'); }
    else if (e.key.toLowerCase() === 'p') { e.preventDefault(); jumpHit('prev'); }
    else if (e.key.toLowerCase() === 'i') { e.preventDefault(); window.manualAdjust('in', 1); }
    else if (e.key.toLowerCase() === 'o') { e.preventDefault(); window.manualAdjust('out', 1); }
  });
  tl.addEventListener('click', (e) => {
    if (!timeline || !currentVideo || !v.duration) return;
    const rect = tl.getBoundingClientRect();
    const t = clamp(Math.floor((e.clientX - rect.left) * timeline.length / rect.width), 0, timeline.length - 1) * binSec;
    v.currentTime = clamp(t, 0, v.duration - 0.01);
  });
  document.getElementById('reload').onclick = loadVideos;
  sel.onchange = () => selectVideo(sel.value);
  document.getElementById('prevF').onclick = () => moveFrame(-1);
  document.getElementById('nextF').onclick = () => moveFrame(1);
  document.getElementById('prevHit').onclick = () => jumpHit('prev');
  document.getElementById('nextHit').onclick = () => jumpHit('next');
  window.addEventListener('resize', () => { resizeCanvasToVideo(); resizeTimeline(); drawTimeline(); updateTimeUI(); });

  async function moveFrame(delta) { if(currentVideo) v.currentTime = (currentFrame() + delta) / FPS + 0.0001; }
  
  async function jumpHit(dir) {
    if (!currentVideo) { console.warn("No video selected."); return; }
    const currentF = currentFrame();
    const url = `/api/videos/${currentVideo}/${dir}_hit?frame=${currentF}`;
    try {
      const r = await fetch(url);
      if (!r.ok) { console.error(`[JumpHit] Server Error: ${r.status}`); return; }
      const j = await r.json();
      if (j.frame !== null && j.frame !== undefined) {
        v.currentTime = j.frame / FPS + 0.0001;
      } else {
        console.warn("[JumpHit] No more hits found.");
      }
    } catch (e) {
      console.error("[JumpHit] Network/JS Error:", e);
    }
  }

  loadVideos();
  tick();
</script>